using System;
using System.IO;
using System.Text;
using System.Reflection;
using System.Collections.Generic;
using System.Collections.Specialized;
using ConfigurationManager = System.Configuration.ConfigurationManager;

using NHibernate;
using NHibernate.Cfg;
using NHibernate.Tool.hbm2ddl;
using NHibernate.Mapping.Attributes;
using Environment = NHibernate.Cfg.Environment;

using Common.Logging;
using Spring.Data.Common;
using Spring.Data.NHibernate;
using Spring.Data.NHibernate.Bytecode;

using GlobalEnglish.Utility.Spring;
using GlobalEnglish.Utility.Values;
using GlobalEnglish.Utility.Parameters;

namespace GlobalEnglish.Utility.Hibernate
{
    /// <summary>
    /// Configures NHibernate with options and model mappings.
    /// </summary>
    /// <remarks>
    /// <h4>Responsibilities:</h4>
    /// <list type="bullet">
    /// <item>configures NHibernate</item>
    /// </list>
    /// <h4>Clients must:</h4>
    /// <list type="bullet">
    /// <item>supply the model assembly(s) during construction or names in App.config</item>
    /// <item>configure the following appSettings (w/examples):</item>
    /// <item>NHibernate.Models - the model assembly names (comma-separated)</item>
    /// <item>NHibernate.ModelDebug - indicates whether to output model mapping files (false)</item>
    /// <item>NHibernate.ModelAccessConvention - the NHibernate model data access convention (field.camelcase)</item>
    /// <item>NHibernate.Dialect - identifies the DB dialect (NHibernate.Dialect.MsSql2005Dialect)</item>
    /// <item>NHibernate.ConnectionDriver - the driver class name (NHibernate.Driver.SqlClientDriver)</item>
    /// <item>NHibernate.ConnectionProvider - the connection class name (NHibernate.Connection.DriverConnectionProvider)</item>
    /// <item>NHibernate.ConnectionString - the connection string (Data Source=.\SqlData;Initial Catalog=Sample;Integrated Security=True)</item>
    /// <item>NHibernate.ReleaseMode - the connection release mode</item>
    /// <item>NHibernate.ShowSQL - indicates whether to show the SQL generated by HQL (false)</item>
    /// <item>NHibernate.FetchDepth - sets the depth of outer join fetches (2)</item>
    /// <item>NHibernate.Optimize - indicates whether to optimize performance (false)</item>
    /// <item>NHibernate.Substitutions - indicates query value substitutions (such as boolean)</item>
    /// <item>NHibernate.ProxyFactory - indicates the proxy factory to use (LinFu)</item>
    /// <item>NHibernate.Cache.ProviderClass - the name of a cache provider class</item>
    /// <item>NHibernate.Cache.MinimizeWrites - indicates whether to minimize cache writes (false)</item>
    /// <item>NHibernate.Cache.RegionPrefix - a 2nd level cache region name prefix</item>
    /// <item>NHibernate.QueryCache.Factory - the name of a query cache factory class</item>
    /// </list>
    /// </remarks>
    public class ConfigurationBuilder
    {
        private static readonly ILog Logger = LogManager.GetLogger(typeof(ConfigurationBuilder));

        internal static readonly String ProxyFactory = "NHibernate.ProxyFactory";
        internal static readonly Type StandardProxyClass = typeof(ProxyFactoryFactory);
        internal static readonly String StandardProxyFactory =
            StandardProxyClass.FullName + ", " + StandardProxyClass.Assembly.GetName().Name;

        internal static readonly String Dialect = "NHibernate.Dialect";
        internal static readonly String StandardDialect = "NHibernate.Dialect.MsSql2005Dialect";

        internal static readonly String Driver = "NHibernate.ConnectionDriver";
        internal static readonly String StandardDriver = "NHibernate.Driver.SqlClientDriver";

        internal static readonly String Provider = "NHibernate.ConnectionProvider";
        internal static readonly String StandardProvider = "NHibernate.Connection.DriverConnectionProvider";

        internal static readonly String Connection = "NHibernate.ConnectionString";
        internal static readonly String SqlConnection = "SqlConnectionString";

        internal static readonly String ModelNames = "NHibernate.Models";
        internal static readonly String ModelDebug = "NHibernate.ModelDebug";
        internal static readonly String Convention = "NHibernate.ModelAccessConvention";

        internal static readonly String ShowSQL = "NHibernate.ShowSQL";
        internal static readonly String FetchDepth = "NHibernate.FetchDepth";
        internal static readonly String Optimize = "NHibernate.Optimize";
        internal static readonly String Substitutions = "NHibernate.Substitutions";
        internal static readonly String ReleaseMode = "NHibernate.ReleaseMode";

        internal static readonly String CacheProvider = "NHibernate.Cache.ProviderClass";
        internal static readonly String MinimizeWrites = "NHibernate.Cache.MinimizeWrites";
        internal static readonly String RegionPrefix = "NHibernate.Cache.RegionPrefix";
        internal static readonly String QueryFactory = "NHibernate.QueryCache.Factory";

        internal static readonly String[] RequiredNames = { Dialect, Driver, Provider, ProxyFactory };

        internal static readonly bool DumpModels =
            ConfiguredValue.Named(ConfigurationBuilder.ModelDebug).To<bool>();

        private List<Assembly> models = new List<Assembly>();
        private Configuration sessionConfiguration;

        #region creating instances
        /// <summary>
        /// Returns a new ConfigurationBuilder.
        /// </summary>
        /// <returns>a new ConfigurationBuilder</returns>
        public static ConfigurationBuilder WithConfiguredModels()
        {
            return ConfigurationBuilder.With(ConfiguredModelNames);
        }

        /// <summary>
        /// Returns a new ConfigurationBuilder.
        /// </summary>
        /// <param name="modelNames">model assembly names</param>
        /// <returns>a new ConfigurationBuilder</returns>
        public static ConfigurationBuilder With(String[] modelNames)
        {
            ConfigurationBuilder result = new ConfigurationBuilder();
            if (!Argument.IsEmpty(modelNames))
            {
                foreach (String modelName in modelNames)
                {
                    result.Models.Add(Assembly.Load(modelName.Trim()));
                }
            }
            return result;
        }

        /// <summary>
        /// Returns a new ConfigurationBuilder.
        /// </summary>
        /// <param name="model">a required model assembly</param>
        /// <returns>a new ConfigurationBuilder</returns>
        public static ConfigurationBuilder With(Assembly model)
        {
            Argument.Check("models", model);
            Assembly[] models = { model };
            return With(models);
        }

        /// <summary>
        /// Returns a new ConfigurationBuilder.
        /// </summary>
        /// <param name="models">required model assemblies</param>
        /// <returns>a new ConfigurationBuilder</returns>
        public static ConfigurationBuilder With(Assembly[] models)
        {
            Argument.CheckAny("models", models);
            return new ConfigurationBuilder(models);
        }

        /// <summary>
        /// Constructs a new ConfigurationBuilder.
        /// </summary>
        /// <param name="models">model assemblies</param>
        private ConfigurationBuilder(Assembly[] models)
        {
            Models.AddRange(models);
        }

        /// <summary>
        /// Constructs a new ConfigurationBuilder.
        /// </summary>
        private ConfigurationBuilder()
        {
        }
        #endregion

        #region checking configuration
        /// <summary>
        /// Checks that the configured dialect matches the expected dialect.
        /// </summary>
        /// <param name="dialectName">a dialect name</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// if the expected dialect was not found</exception>
        public void CheckDialect(string dialectName)
        {
            if (!SessionConfiguration.GetProperty(Environment.Dialect).Contains(dialectName))
            {
                throw new ArgumentOutOfRangeException(
                            Dialect, "Expected " + Dialect + " to be " + dialectName);
            }
        }

        /// <summary>
        /// Checks that the configured connection string contains a known database name.
        /// </summary>
        /// <param name="databaseName">identifies a known database</param>
        public void CheckConnection(string databaseName)
        {
            String connectionName = ConfiguredValue.Named(Connection + ".Name");
            if (Argument.IsPresent(connectionName))
            {
                string connectionString = 
                    ConfiguredValue.ConnectionSettingsNamed(connectionName).ConnectionString;

                if (!connectionString.Contains(databaseName))
                    throw new ArgumentOutOfRangeException(
                                Connection, "Expected connection string to contain " + databaseName);
            }

            String optionValue = ConfiguredValue.Named(Connection);
            if (Argument.IsAbsent(optionValue))
                optionValue = ConfiguredValue.ConnectionNamed(optionValue);

            if (Argument.IsPresent(optionValue) && !optionValue.Contains(databaseName))
                throw new ArgumentOutOfRangeException(
                            Connection, "Expected connection string to contain " + databaseName);
        }
        #endregion

        #region building configurations
        /// <summary>
        /// Builds a database from a configuration.
        /// </summary>
        public void BuildDatabase()
        {
            SchemaExport tool = SchemaExportTool;
            tool.Drop(DumpModels, true);
            tool.Create(DumpModels, true);
            return;
        }

        /// <summary>
        /// The sessionConfiguration.
        /// </summary>
        public Configuration SessionConfiguration
        {
            get
            {
                if (this.sessionConfiguration == null)
                {
                    this.sessionConfiguration = BuildConfiguration(String.Empty);
                }

                return this.sessionConfiguration;
            }
        }

        /// <summary>
        /// Builds a session factory.
        /// </summary>
        /// <param name="prefix">a configured name prefix</param>
        /// <returns>a session factory</returns>
        public ISessionFactory BuildSessionFactory(String prefix)
        {
            return BuildConfiguration(prefix).BuildSessionFactory();
        }

        /// <summary>
        /// Returns a new configuration.
        /// </summary>
        /// <param name="prefix">a configured name prefix</param>
        /// <returns>a new configuration</returns>
        private Configuration BuildConfiguration(String prefix)
        {
            Configuration cfg = new Configuration();

            cfg.ConfigureProperty(Environment.Dialect, prefix + Dialect, StandardDialect);
            cfg.ConfigureProperty(Environment.ConnectionDriver, prefix + Driver, StandardDriver);
            cfg.ConfigureProperty(Environment.ConnectionProvider, prefix + Provider, StandardProvider);
            cfg.ConfigureProperty(Environment.ProxyFactoryFactoryClass, prefix + ProxyFactory, StandardProxyFactory);

            cfg.ConfigureOption(Environment.ShowSql, ShowSQL);
            cfg.ConfigureOption(Environment.UseMinimalPuts, MinimizeWrites);
            cfg.ConfigureOption(Environment.QuerySubstitutions, Substitutions);
            cfg.ConfigureOption(Environment.PropertyUseReflectionOptimizer, Optimize);

            cfg.ConfigureProperty(Environment.ReleaseConnections, ReleaseMode);
            cfg.ConfigureProperty(Environment.MaxFetchDepth, FetchDepth);
            cfg.ConfigureProperty(Environment.CacheProvider, CacheProvider);
            cfg.ConfigureProperty(Environment.CacheRegionPrefix, RegionPrefix);

            cfg.ConfigureQueryFactory(QueryFactory);
            cfg.ConfigureConnection(prefix + Connection);
            cfg.ConfigureModels(Models.ToArray());

            //if (HasManagedTransactions)
            //{
            //    cfg.SetProperty(Environment.CurrentSessionContextClass, SessionContextClassName);
            //}

            return cfg;
        }
        #endregion

        #region accessing parts
        /// <summary>
        /// The full session context class name.
        /// </summary>
        public static string SessionContextClassName
        {
            get
            {
                Type contextType = typeof(SpringSessionContext);
                return contextType.FullName + ", " + contextType.Assembly.GetName().Name;
            }
        }

        /// <summary>
        /// The configured model names.
        /// </summary>
        public static String[] ConfiguredModelNames
        {
            get
            {
                String[] empty = { };
                String models = ConfiguredValue.Named(ModelNames);
                if (Argument.IsAbsent(models)) return empty;
                return models.Split(',');
            }
        }

        /// <summary>
        /// Returns the configured model names.
        /// </summary>
        /// <param name="namePrefix">a configured value prefix</param>
        /// <returns>the configured model names</returns>
        public static String[] GetConfiguredModelNames(String namePrefix)
        {
            String[] empty = { };
            String models = ConfiguredValue.Named(namePrefix + ModelNames);
            if (Argument.IsAbsent(models)) return empty;
            return models.Split(',');
        }

        /// <summary>
        /// A schema export.
        /// </summary>
        public SchemaExport SchemaExportTool
        {
            get { return new SchemaExport(SessionConfiguration); }
        }

        /// <summary>
        /// A configured session factory.
        /// </summary>
        public ISessionFactory ConfiguredSessionFactory
        {
            get
            {
                try
                {
                    return SessionConfiguration.BuildSessionFactory();
                }
                finally
                {
                    Logger.Info("Configured and built a Hibernate session factory");
                }
            }
        }

        /// <summary>
        /// The models.
        /// </summary>
        private List<Assembly> Models
        {
            get { return this.models; }
        }

        /// <summary>
        /// The configured database provider.
        /// </summary>
        public IDbProvider DatabaseProvider
        {
            get
            {
                string connectionName = ConfiguredValue.Named(Connection + ".Name");
                if (Argument.IsAbsent(connectionName)) return null;

                System.Configuration.ConnectionStringSettings settings = 
                    ConfiguredValue.ConnectionSettingsNamed(connectionName);

                if (settings == null) return null;
                return DbProviderFactory.GetDbProvider(settings.ProviderName);
            }
        }

        /// <summary>
        /// Indicates whether the configuration contains a transaction manager.
        /// </summary>
        public bool HasManagedTransactions
        {
            get { return SpringContext.HasConfigured("transactionManager"); }
        }
        #endregion

    } // ConfigurationBuilder

    /// <summary>
    /// Extends collaborator classes to support extra behaviors.
    /// </summary>
    public static class BuilderExtension
    {
        /// <summary>
        /// Configures a boolean option.
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="optionName">an option name</param>
        /// <param name="valueName">a configured value name</param>
        public static void ConfigureOption(this Configuration cfg, String optionName, String valueName)
        {
            cfg.ConfigureProperty(optionName, valueName, "false");
        }

        /// <summary>
        /// Configures a property.
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="optionName">an option name</param>
        /// <param name="valueName">a configured value name</param>
        public static void ConfigureProperty(this Configuration cfg, String optionName, String valueName)
        {
            String optionValue = ConfiguredValue.Named(valueName);
            if (Argument.IsPresent(optionValue))
                cfg.SetProperty(optionName, optionValue);
        }

        /// <summary>
        /// Configures a property.
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="optionName">an option name</param>
        /// <param name="valueName">a configured value name</param>
        /// <param name="standardValue">a standard value</param>
        internal static void ConfigureProperty(
            this Configuration cfg, String optionName, String valueName, String standardValue)
        {
            cfg.SetProperty(optionName, ConfiguredValue.Named(valueName, standardValue));
        }

        /// <summary>
        /// Configures a query factory (if present).
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="valueName">a configured factory name</param>
        public static void ConfigureQueryFactory(this Configuration cfg, String valueName)
        {
            String factoryName = ConfiguredValue.Named(valueName);
            if (Argument.IsPresent(factoryName))
            {
                cfg.SetProperty(Environment.QueryCacheFactory, factoryName);
                cfg.SetProperty(Environment.UseQueryCache, "true");
            }
        }

        /// <summary>
        /// Configures a connection.
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="valueName">a configured connection name</param>
        public static void ConfigureConnection(this Configuration cfg, String valueName)
        {
            String connectionName = ConfiguredValue.Named(valueName + ".Name");
            if (Argument.IsPresent(connectionName))
            {
                cfg.SetProperty(Environment.ConnectionStringName, connectionName);
                return;
            }

            String optionValue = ConfiguredValue.Named(valueName);
            if (Argument.IsAbsent(optionValue))
                optionValue = ConfiguredValue.ConnectionNamed(optionValue);

            if (Argument.IsPresent(optionValue))
                cfg.SetProperty(Environment.ConnectionString, optionValue);
        }

        /// <summary>
        /// Configures a model access convention.
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="valueName">a configured convention name</param>
        public static void ConfigureConvention(this Configuration cfg, String valueName)
        {
            String convention = ConfiguredValue.Named(valueName);
            if (Argument.IsPresent(convention))
            {
                HbmSerializer.Default.HbmDefaultAccess = convention;
            }
        }

        /// <summary>
        /// Adds the model mappings to a configuration.
        /// </summary>
        /// <param name="cfg">a configuration</param>
        /// <param name="models">some model assemblies</param>
        public static void ConfigureModels(this Configuration cfg, Assembly[] models)
        {
            HbmSerializer.Default.Validate = true;
            cfg.ConfigureConvention(ConfigurationBuilder.Convention);

            foreach (Assembly model in models)
            {
                if (ConfigurationBuilder.DumpModels) model.DumpHibernateXml();
                cfg.AddXml(model.GenerateMappings());
            }
            return;
        }

        /// <summary>
        /// Dumps a copy of the model XML in a file.
        /// </summary>
        /// <param name="model">a model assembly</param>
        public static void DumpHibernateXml(this Assembly model)
        {
            String modelFile = model.GetName().Name + ".hbm.xml";
            File.WriteAllText(modelFile, model.GenerateMappings());
        }

        /// <summary>
        /// Generates the mappings for a model assembly.
        /// </summary>
        /// <param name="model">a model assembly</param>
        /// <returns>the mapping XML</returns>
        public static String GenerateMappings(this Assembly model)
        {
            using (MemoryStream stream = HbmSerializer.Default.Serialize(model))
            using (StreamReader reader = new StreamReader(stream))
            {
                return reader.ReadToEnd();
            }
        }

    } // BuilderExtension
}
